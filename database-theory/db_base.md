## 数据库底层实现


[课程链接](https://www.bilibili.com/video/BV1vg41157CA)
[相应的思维导图](https://www.processon.com/view/link/5eccea8fe0b34d5f263038f0#map)
### 收货：

#### P2
1. 数据底层数据结构的变迁，二叉树-->红黑树-->B-树-->B+树
2. 二叉树在创建时，会因为数据的有序性影响其高度， 进而使得其性能时好时坏， 在特定场景下（全排序），性能与普通遍历无异
3. 红黑树的深度会随着数据量的增加而增加
4. B-数每个节点自带数据（或者数据的存放地址）
5. B+数每个非子叶节点只带索引值， 而不带数据或其地址， 但是其子叶节点（在同一层）还是一个有序链表，类似在这个有序链表上附着了一层多叉树，方便其进行索引（见问题2）

#### P3
1. TODO big question 既然B+数本质上也是通过二分法查找， 那么为何不直接载入所有索引来进行二分法查询呢？（因为内存可能不够，不方便一次性加入）
2. TODO 这引来了另一个问题， 也就是说，由这个B+树构成的内存数据， 会随着新访问的增加，动态变化， 这个过程最好探究一下(buffer bool)
3. 但是随着， 对数据访问记录越来越全， 加载到这个内存中的数据会越来越多， 必然会出现内存不够的问题， 这也引出了P4的内容

#### P4
1. 使用MYISAM数据引擎的数据表由三个文件保存， 表的结构(frm)， 表的数据(MYD)， 表的索引(MYI) 
2. 而InnoDB使用两个文件保存（frm与idb）, 后者为索引
3. 将索引与数据存在一起（InnoDB）叫做聚集/聚簇/非稀疏索引，否则叫非聚集性索引（它们的差别很大吗）
4. 主键索引(Primary Key)与非主键(Secondary Key)索引
非主键索引是建立非主键与主键的索引（B+树），然后通过两次B+数搜索找到目标

#### P5
1. TODO InnoDB在用户没有设置主键的情况下，首先会分析哪一个字段具有唯一性， 选取这个唯一的字段作为主键? 这很离谱， mysql怎么知道一万零一次会不会与之前的重复?
2. 如果上一个步骤会自行生成一个隐藏的唯一字段（rowId）来构建B+树
3. 主键尽量用整形， 字符串最终也是要转换为整形比较
4. 为什么推荐用自增的主键？
#### P6
1. hash的速度为O(1)，但是不支持范围查找， 并且会出现hash冲突
2. hash不能做范围查找, B+通过将叶子节点双向串联起来可以实现范围查找
3. UUID和自增作为主键的区别: 主键自增相对于不自增， 写入速度更快， 首先不用查找插入位置（我的想法）， 其次可以避免B+节点的分裂
4. 左前缀原则： 联合主键是有顺序的， 如果不优先使用前面的主键做搜索(准确说不使用第一个主键)， 会使效率降低， 因为没有联合索引是在第一个主键的基础上建立的

#### P7
1. 联合索引是有顺序的， 可以理解为将多个有序字段拼成一个字段作为索引（个人猜想）
2. 然后比较大小是从高位开始比对（个人猜想）， 所以， 索引的时候需要按组成联合索引的字段顺序添加查询条件， 称为`左前缀原则`
3. 如果索引是`name age position`， 那么where age=10 and name=Andy会走索引吗？

#### P10
1. 原子性 一致性 隔离性 持久性
2. undolog redolog binlog

### 问题:
1. 为什么红黑树每经历一个节点，需要对磁盘进行一次IO，不可以像B+数一样预先读出来载入到内存吗?(P2)
2. 既然B+的子叶节点构成了一个有序链表，为啥不就在这个链表基础上进行二分法查找呢？
答： 因为B+的一个节点有多个数据的索引， 加载一个节点，就相当于加载了很多个数据节点
3. 为什么B+数的节点容量达到最大容量的15/16后就会分裂， 为什么是15/16？
4. 为什么mysql将B+树每个节点最大容量设置为16k`SHOW GLOBAL STATUS LIKE 'Innodb_page_size'`
5. 蛮好奇， 如果用一个普通的建做搜索， 它的检索机制是怎样的？

>> P3
5. 如何设置索引字段?
6. 设置索引字段意味着什么?
>>P5
7. 为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键?
8. InnoDB如何判断某一字段是唯一的？比如设置表的时候声明Primary Key?
>> P6
9. 当使用hash作为数据库检索时，出现hash冲突会把这个hash值所对应的数组中的元素以链表形式串起来， 从而出现一对多的情况？
10. B树与B+树的区别？


